# Queen Navigation Optimizing Notes

Once I had completed some of the initial boilerplate and scaffolding for the
project, I added some performance benchmarks for different functions throughout
the project. Before implementing the solution algorithm, I wanted to have an
understanding of what actions were the most computationally intensive, and
see where any changes were needed.

After completing this, I found that the logic related to finding uncontested
spaces was one of the slowest functions, as an extension of the fact that
the logic for finding an individual queen's possible moves was somewhat
expensive as well.

## Original Implementation

Let's start by looking at the original logic behind calculating a queen's
available moves. This looked like this:

```rust
fn get_queen_moves(&self, pos: PosCoords) -> HashSet<PosCoords> {
    [
        &self.get_n_moves(pos),
        &self.get_s_moves(pos),
        &self.get_w_moves(pos),
        &self.get_e_moves(pos),
        &self.get_nw_moves(pos),
        &self.get_ne_moves(pos),
        &self.get_sw_moves(pos),
        &self.get_se_moves(pos),
    ].iter()
        .fold(HashSet::new(), |res, dir| res.union(dir).cloned().collect())
}
```

This invokes some helper methods to find the moves in each direction. These
looked like this, note that we will only look at `get_n_moves` and
`get_ne_moves` because the others follow very similar patterns respective to
whether or not they represent diagonal motion.

```rust
fn get_n_moves(&self, pos: PosCoords) -> HashSet<PosCoords> {
    (pos.1..self.height).map(|y| (pos.0, y)).collect()
}

fn get_ne_moves(&self, pos: PosCoords) -> HashSet<PosCoords> {
    let dis_to_edge = min(self.width - pos.0, self.height - pos.1);
    (0..dis_to_edge)
        .map(|delta| (pos.0 + delta, pos.1 + delta))
        .collect()
}
```

I added some benchmarking tests that would test how long `get_queen_moves`,
`get_n_moves`, and `get_ne_moves` would take to complete from a random
position on a default 8x8 board. This resulted in the following statistics:

```
test get_queen_moves ... bench:       9,546 ns/iter (+/- 237)
test get_queen_n_moves ... bench:         280 ns/iter (+/- 1)
test get_queen_ne_moves ... bench:         121 ns/iter (+/- 38)
```

NOTE: The above stats were generated by running the `cargo bench` command, and
have had their full paths edited for the sake of brevity.

For reference, other functions that rely on finding the moves that queens
could make, ran in these times:

```
test get_uncontested_spaces_with_empty_board_bench ... bench: 30,976 ns/iter (+/- 745)
test get_uncontested_spaces_with_two_queens_bench ... bench: 30,272 ns/iter (+/- 1,055)
test get_uncontested_spaces_with_four_queens_bench ... bench: 56,084 ns/iter (+/- 1,862)
test get_uncontested_spaces_with_seven_queens_bench ... bench: 98,151 ns/iter (+/- 3,878)
```

### Hypothesizing Improvements

The fact that diagonal movement functions were actually faster on average than
the vertical/horizontal movement functions was interesting to me. This at the
very least implied to me that the individual movement functions were probably
not the place to start optimizing.

There was a better hint about why the `get_queen_moves` function itself, rather
than the underlying helper methods, could be improved. Why?

A queen can move in one of eight possible directions. If finding the available
squares in a given direction takes ~200ns (using the current implementation),
then the `get_queen_moves` should take at least `(8 * 200) = 1600ns`. Anything
beyond that we can consider to be overhead related to the `get_queen_moves`
function itself.

There is a diifferent of ~8000ns here, so this function can almost certainly
be improved. This would in turn improve the runtime of the function used to
find the coordinates of uncontested spaces on the board.

Recall that the `get_queen_moves` function ends with a call to `fold` that looks
like this:

```rust
.fold(HashSet::new(), |res, dir| res.union(dir).cloned().collect())
```

At each iteration of the folding process, we must clone the elements in the
resulting union of two hash sets, and place them in a new result object.

Instead of this implementation, what if we refactored the navigation
helper functions so that each returned a `Vec<PosCoords>` object, and collected
a single `HashSet` object after using `flat_map`? This would hopefully remove
the need to repeatedly clone and collect the `HashSet` that
`get_queen_moves` returns.

## Faster Implementation

To reduce the number of times that data needs to be cloned, I first started by
adjusting each of the helper functions so that they would return `Vec` objects,
and combined some of the simple up/down/left/right functions. The logic remained
mostly identical here, and most of the work related to refactoring test benches.

```rust
fn get_vert_moves(&self, pos: PosCoords) -> Vec<PosCoords> {
    (0..self.height).map(|y| (pos.0, y)).collect()
}

fn get_ne_moves(&self, pos: PosCoords) -> Vec<PosCoords> {
    let dis_to_edge = min(self.width - pos.0, self.height - pos.1);
    (0..dis_to_edge)
        .map(|delta| (pos.0 + delta, pos.1 + delta))
        .collect()
}
```

Once this was complete, I needed to rework the `get_queen_moves` function.

```rust
fn get_queen_moves(&self, pos: PosCoords) -> HashSet<PosCoords> {
    [
        self.get_vert_moves(pos),
        self.get_horiz_moves(pos),
        self.get_nw_moves(pos),
        self.get_ne_moves(pos),
        self.get_sw_moves(pos),
        self.get_se_moves(pos),
    ].iter()
        .flatten()
        .cloned()
        .collect()
```

This uses an experimental nightly feature, `flatten`. The first step is
creating a vector of vectors, each containing the available coordinates in
a given direction. Each of these vectors is flattened into a single vector.
We clone the elements in this resulting vector of coordinate references, and
collect them into a single hash set object.

After this was done, I ran my benchmarks once more, and found that the times
had improved considerably, as shown below:

```
test get_queen_moves ... bench: 1,578 ns/iter (+/- 52)
test get_uncontested_spaces_with_empty_board_bench ... bench: 7,560 ns/iter (+/- 226)
test get_uncontested_spaces_with_four_queens_bench ... bench: 25,173 ns/iter (+/- 479)
test get_uncontested_spaces_with_seven_queens_bench ... bench: 41,674 ns/iter (+/- 1,250)
test get_uncontested_spaces_with_two_queens_bench ... bench: 14,765 ns/iter (+/- 280)
```

The `get_queen_moves` function now ran in 15% of the time! This was also much
closer to what I considered to be the ideal runtime of the function. Further,
this also dramatically improved the runtime of the function used to identify
uncontested spaces on the board, taking less than half of the original time.
