# Queen Navigation Optimizing Notes

Once I had completed some of the initial boilerplate and scaffolding for the
project, I added some performance benchmarks for different functions throughout
the project. Before implementing the solution algorithm, I wanted to have an
understanding of what actions were the most computationally intensive, and
see where any changes were needed.

After completing this, I found that the logic related to finding uncontested
spaces was one of the slowest functions, as an extension of the fact that
the logic for finding an individual queen's possible moves was somewhat
expensive as well.

## Before

Let's start by looking at the original logic behind calculating a queen's
available moves. This looked like this:

```rust
fn get_queen_moves(&self, pos: PosCoords) -> HashSet<PosCoords> {
    [
        &self.get_n_moves(pos),
        &self.get_s_moves(pos),
        &self.get_w_moves(pos),
        &self.get_e_moves(pos),
        &self.get_nw_moves(pos),
        &self.get_ne_moves(pos),
        &self.get_sw_moves(pos),
        &self.get_se_moves(pos),
    ].iter()
        .fold(HashSet::new(), |res, dir| res.union(dir).cloned().collect())
}
```

This invokes some helper methods to find the moves in each direction. These
looked like this, note that we will only look at `get_n_moves` and
`get_ne_moves` because the others follow very similar patterns respective to
whether or not they represent diagonal motion.

```rust
fn get_n_moves(&self, pos: PosCoords) -> HashSet<PosCoords> {
    (pos.1..self.height).map(|y| (pos.0, y)).collect()
}

fn get_ne_moves(&self, pos: PosCoords) -> HashSet<PosCoords> {
    let dis_to_edge = min(self.width - pos.0, self.height - pos.1);
    (0..dis_to_edge)
        .map(|delta| (pos.0 + delta, pos.1 + delta))
        .collect()
}
```

I added some benchmarking tests that would test how long `get_queen_moves`,
`get_n_moves`, and `get_ne_moves` would take to complete from a random
position on a default 8x8 board. This resulted in the following statistics:

```
test get_queen_moves ... bench:       9,546 ns/iter (+/- 237)
test get_queen_n_moves ... bench:         280 ns/iter (+/- 1)
test get_queen_ne_moves ... bench:         121 ns/iter (+/- 38)
```

NOTE: The above stats were generated by running the `cargo bench` command, and
have had their full paths edited for the sake of brevity.

For reference, other functions that rely on finding the moves that queens
could make, ran in these times:

```
test get_uncontested_spaces_with_empty_board_bench ... bench: 30,976 ns/iter (+/- 745)
test get_uncontested_spaces_with_two_queens_bench ... bench: 30,272 ns/iter (+/- 1,055)
test get_uncontested_spaces_with_four_queens_bench ... bench: 56,084 ns/iter (+/- 1,862)
test get_uncontested_spaces_with_seven_queens_bench ... bench: 98,151 ns/iter (+/- 3,878)
```

### Hypothesizing Improvements

The fact that diagonal movement functions were actually faster on average than
the vertical/horizontal movement functions was interesting to me. This at the
very least implied to me that the individual movement functions were probably
not the place to start optimizing.

There was a better hint about why the `get_queen_moves` function itself, rather
than the underlying helper methods, could be improved. Why?

A queen can move in one of eight possible directions. If finding the available
squares in a given direction takes ~200ns (using the current implementation),
then the `get_queen_moves` should take at least `(8 * 200) = 1600ns`. Anything
beyond that we can consider to be overhead related to the `get_queen_moves`
function itself.

There is a diifferent of ~8000ns here, so this function can almost certainly
be improved. This would in turn improve the runtime of the function used to
find the coordinates of uncontested spaces on the board.

Recall that the `get_queen_moves` function ends with a call to `fold` that looks
like this:

```rust
.fold(HashSet::new(), |res, dir| res.union(dir).cloned().collect())
```

At each iteration of the folding process, we must clone the elements in the
resulting union of two hash sets, and place them in a new result object.

Instead of this implementation, what if we refactored the navigation
helper functions so that each returned a `Vec<PosCoords>` object, and collected
a single `HashSet` object after using `flat_map`? This would hopefully remove
the need to repeatedly clone and collect the `HashSet` that
`get_queen_moves` returns.
